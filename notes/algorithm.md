

ğŸ”´ éš¾åº¦ç­‰çº§ï¼ˆä¸ä¼šåšï¼‰

ğŸ˜Šä¼š

- [æ’åºç®—æ³•](#æ’åºç®—æ³•)
  - [å¿«é€Ÿæ’åº](#å¿«é€Ÿæ’åº)
  - [å †æ’åº](#å †æ’åº)
- [ä¼˜å…ˆé˜Ÿåˆ—+è´ªå¿ƒ](#ä¼˜å…ˆé˜Ÿåˆ—è´ªå¿ƒ)
  - [LCP 30. é­”å¡”æ¸¸æˆ](#lcp-30-é­”å¡”æ¸¸æˆ)
  - [LCP 32. æ‰¹é‡å¤„ç†ä»»åŠ¡](#lcp-32-æ‰¹é‡å¤„ç†ä»»åŠ¡)
- [åŠ¨æ€è§„åˆ’](#åŠ¨æ€è§„åˆ’)
  - [LCP 31. å˜æ¢çš„è¿·å®«](#lcp-31-å˜æ¢çš„è¿·å®«)
  - [312. æˆ³æ°”çƒ](#312-æˆ³æ°”çƒ)
  - [410. åˆ†å‰²æ•°ç»„çš„æœ€å¤§å€¼](#410-åˆ†å‰²æ•°ç»„çš„æœ€å¤§å€¼)
  - [6100. ç»Ÿè®¡æ”¾ç½®æˆ¿å­çš„æ–¹å¼æ•°](#6100-ç»Ÿè®¡æ”¾ç½®æˆ¿å­çš„æ–¹å¼æ•°)
- [å­—å…¸æ ‘](#å­—å…¸æ ‘)
  - [440. å­—å…¸åºçš„ç¬¬Kå°æ•°å­—](#440-å­—å…¸åºçš„ç¬¬kå°æ•°å­—)
- [äºŒå‰æ ‘+DP](#äºŒå‰æ ‘dp)
  - [LCP 34. äºŒå‰æ ‘æŸ“è‰²](#lcp-34-äºŒå‰æ ‘æŸ“è‰²)
- [æ•°å­¦](#æ•°å­¦)
  - [172. é˜¶ä¹˜åçš„é›¶](#172-é˜¶ä¹˜åçš„é›¶)
- [ä½è¿ç®—](#ä½è¿ç®—)
  - [å‰‘æŒ‡ Offer II 001. æ•´æ•°é™¤æ³•](#å‰‘æŒ‡-offer-ii-001-æ•´æ•°é™¤æ³•)
  - [Dasha and Nightmares](#dasha-and-nightmares)
  - [982. æŒ‰ä½ä¸ä¸ºé›¶çš„ä¸‰å…ƒç»„](#982-æŒ‰ä½ä¸ä¸ºé›¶çš„ä¸‰å…ƒç»„)
- [å¹¶æŸ¥é›†](#å¹¶æŸ¥é›†)
  - [ P1111ä¿®å¤å…¬è·¯ - æ´›è°·](#-p1111ä¿®å¤å…¬è·¯---æ´›è°·)
  - [P3958 \[NOIP2017 æé«˜ç»„\] å¥¶é…ª - æ´›è°· ](#p3958-noip2017-æé«˜ç»„-å¥¶é…ª---æ´›è°·-)
  - [685. å†—ä½™è¿æ¥ II](#685-å†—ä½™è¿æ¥-ii)
  - [924. å°½é‡å‡å°‘æ¶æ„è½¯ä»¶çš„ä¼ æ’­](#924-å°½é‡å‡å°‘æ¶æ„è½¯ä»¶çš„ä¼ æ’­)
- [çº¿æ®µæ ‘](#çº¿æ®µæ ‘)
  - [307. åŒºåŸŸå’Œæ£€ç´¢ - æ•°ç»„å¯ä¿®æ”¹](#307-åŒºåŸŸå’Œæ£€ç´¢---æ•°ç»„å¯ä¿®æ”¹)
  - [LCP 05. å‘ LeetCoin](#lcp-05-å‘-leetcoin)
- [å¹¿åº¦ä¼˜å…ˆæœç´¢](#å¹¿åº¦ä¼˜å…ˆæœç´¢)
  - [LCP 09. æœ€å°è·³è·ƒæ¬¡æ•°](#lcp-09-æœ€å°è·³è·ƒæ¬¡æ•°)
  - [675. ä¸ºé«˜å°”å¤«æ¯”èµ›ç æ ‘](#675-ä¸ºé«˜å°”å¤«æ¯”èµ›ç æ ‘)
- [æ‹“æ‰‘æ’åº](#æ‹“æ‰‘æ’åº)
  - [310. æœ€å°é«˜åº¦æ ‘](#310-æœ€å°é«˜åº¦æ ‘)
- [æ»‘åŠ¨çª—å£](#æ»‘åŠ¨çª—å£)
  - [30. ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²](#30-ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²)
- [äºŒåˆ†](#äºŒåˆ†)
  - [ å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](#-å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°)
- [Rolling Hash](#rolling-hash)
  - [Remove Two Letters](#remove-two-letters)
- [æ¢æ ¹DP](#æ¢æ ¹dp)
  - [ç»Ÿè®¡å¯èƒ½çš„æ ‘æ ¹æ•°ç›®](#ç»Ÿè®¡å¯èƒ½çš„æ ‘æ ¹æ•°ç›®)
  - [Problem - 219D - Codeforces](#problem---219d---codeforces)
- [æ±‚é€†åºå¯¹](#æ±‚é€†åºå¯¹)
  - [æš´åŠ›æ±‚è§£](#æš´åŠ›æ±‚è§£)
  - [å½’å¹¶æ’åº](#å½’å¹¶æ’åº)
  - [æ ‘çŠ¶æ•°ç»„](#æ ‘çŠ¶æ•°ç»„)



# æ’åºç®—æ³•

## å¿«é€Ÿæ’åº

```java
public class Solution {
    public static void main(String[] args) {
        int[] nums = new int[]{102,32,43,43,5,656,657,5665,65,56,5,567,78,1,23,455,6};
        new Solution().sort(nums);
        for (int i = 0; i < nums.length; i++) {
            System.out.print(nums[i]+" ");
        }
    }


    public void sort(int[] nums){
        quickSort(nums,0,nums.length-1);
    }
    private void quickSort(int[] nums, int left, int right){
        if(left < right){
            int k = partition(nums,left,right);
            quickSort(nums,left,k-1);
            quickSort(nums,k+1,right);
        }
    }
    private int partition(int[] nums, int left, int right){
        int pix = nums[left];
        while (left < right){
            while (left < right && nums[right] >= pix){
                right --;
            }
            if(left < right)    nums[left] = nums[right];
            while (left < right && nums[left] < pix){
                left ++;
            }
            if(left < right)    nums[right] = nums[left];
        }
        nums[left] = pix;
        return left;
    }
}
```



## å †æ’åº

```java
public class Solution {
    public static void main(String[] args) {
        int[] nums = new int[]{102,32,43,43,5,656,657,5665,65,56,5,567,78,1,23,455,6};
        new Solution().sort(nums);
        for (int i = 0; i < nums.length; i++) {
            System.out.print(nums[i]+" ");
        }
    }


    public void sort(int[] nums){
        int len = nums.length - 1;
        int beginIndex = (len - 1) >> 1;
        for (int i = beginIndex; i >= 0; i--) {
            maxHeapify(nums,i,len);
        }


        for (int i = len; i >= 0; i--) {
            swap(nums,0,i);
            maxHeapify(nums,0,i-1);
        }

    }
    private void maxHeapify(int[] nums, int index, int len){
        int li = (index << 1) + 1;
        int ri = li + 1;
        int cMax = li;
        if(li > len)    return;
        if(ri <= len && nums[ri] > nums[li]){
            cMax = ri;
        }
        if(nums[cMax] > nums[index]){
            swap(nums,cMax,index);
            maxHeapify(nums,cMax,len);
        }
    }


    private void swap(int[] nums,int i, int j){
        if(i == j)  return;
        nums[i] = nums[i] ^ nums[j];
        nums[j] = nums[i] ^ nums[j];
        nums[i] = nums[i] ^ nums[j];
    }

}
```





# ä¼˜å…ˆé˜Ÿåˆ—+è´ªå¿ƒ



## [LCP 30. é­”å¡”æ¸¸æˆ](https://leetcode-cn.com/problems/p0NxJO/)

![image-LCP 30. é­”å¡”æ¸¸æˆ](./images/LCP%2030.%20é­”å¡”æ¸¸æˆ.png)



```java
class Solution {
    public int magicTower(int[] nums) {
        int ans = 0;
        long now = 1L;
        long last = 0;
        PriorityQueue<Integer> pq = new PriorityQueue<>();
    
        for(int i=0; i<nums.length; ++i){
            if(nums[i] < 0) pq.offer(nums[i]);
            now += nums[i];
            // å½“ç°åœ¨çš„è¡€é‡ now å°äº1æ—¶ï¼Œéœ€è¦è¿›è¡Œè°ƒæ•´ï¼Œå¦åˆ™æ­»äº¡
            // æ¯æ¬¡è°ƒæ•´éƒ½ä¼šå°†å·²ç»éå†è¿‡çš„æœ€å°å€¼è°ƒæ•´åˆ°æœ«å°¾
            if(now <= 0){
                // è®°å½•æ€»å…±è°ƒæ•´çš„æ€ªç‰©çš„è¡€é‡æ€»å’Œ(è‚¯å®šéƒ½æ˜¯è´Ÿæ•°æ»´)
                last += pq.peek();
                // æ¯æ¬¡ç§»é™¤æœ€å°å€¼
                now -= pq.poll(); 
                ans ++;
            }
        }

        // ç»å†è¿‡æ‰€æœ‰æˆ¿é—´ä¹‹åçš„è¡€é‡å¤§äº 0 æ‰ä¼šé€šè¿‡
        if(now + last > 0)  return ans;
        return -1;
    }
}
```

## [LCP 32. æ‰¹é‡å¤„ç†ä»»åŠ¡](https://leetcode-cn.com/problems/t3fKg1/)

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

```java
class Solution {
        public int processTasks(int[][] tasks) {
        int[][] newTasks = new int[tasks.length + 1][];
        //æŒ‰èµ·ç‚¹æ’åº
        Arrays.sort(tasks, (task1, task2) -> task1[0] - task2[0]);        
        System.arraycopy(tasks, 0, newTasks, 0, tasks.length);
        newTasks[tasks.length] = new int[]{1000000001, 1000000001, 1};
        int res = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        for (int[] task : newTasks) {
            while (!pq.isEmpty() && pq.peek()[0] + res < task[0]) {
                if (pq.peek()[0] + res >= pq.peek()[1]) {
                    pq.poll();
                }else {
                    res += Math.min(pq.peek()[1], task[0]) - (pq.peek()[0] + res);
                }
            }
            pq.offer(new int[]{task[1] - task[2] + 1 - res,task[1] + 1});
        }
        return res;
    }
}
```



# åŠ¨æ€è§„åˆ’

## [LCP 31. å˜æ¢çš„è¿·å®«](https://leetcode-cn.com/problems/Db3wC1/)

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

```java
class Solution {
    public boolean escapeMaze(List<List<String>> maze) {
        // æ—¶é—´
        int t = maze.size();    
        // é•¿
        int m = maze.get(0).size();
        // å®½
        int n = maze.get(0).get(0).length();
        // 0æœªä½¿ç”¨ 1ä½¿ç”¨ä¸´æ—¶å·è½´ 2ä½¿ç”¨æ°¸ä¹…å·è½´ 3ä½¿ç”¨å®Œ
        boolean[][][][] dp = new boolean[t][m][n][4];
        for(int i=0; i<4; ++i){
            dp[0][0][0][i] = true;
        }
        // è½¬ç§»æ–¹å‘
        int[][] dire = new int[][] { { 0, 0 }, { 0, -1 }, { -1, 0 }, { 0, 1 }, { 1, 0 } };
        // ä½¿ç”¨æ°¸ä¹…å·èƒ½åˆ°è¾¾æ–¹å‘
        boolean[][][] can = new boolean[m][n][2];
        for(int i=1; i<t; ++i){
            for(int j=0; j<m; ++j){
                for(int k=0; k<n; ++k){
                    dp[i][j][k][2] |= can[j][k][0];
                    dp[i][j][k][3] |= can[j][k][1];
                    // å½“å‰ä¸ºç©ºåœ°çš„è¯ï¼Œç›´æ¥è½¬ç§»å³å¯
                    if (maze.get(i).get(j).charAt(k) == '.') {
                        for (int l = 0; l < 4; ++l) {
                            for (int p = 0; p < 5; ++p) {
                                int dx = j + dire[p][0], dy = k + dire[p][1];
                                if (dx >= 0 && dx < m && dy >= 0 && dy < n) {
                                    dp[i][j][k][l] |= dp[i - 1][dx][dy][l];
                                }
                            }
                        }
                        // å¦åˆ™ï¼Œåªèƒ½ä½¿ç”¨å·è½´è½¬ç§»,ä¹Ÿå°±æ˜¯ä¹‹å‰è¦æ²¡ä½¿ç”¨è¿‡ç›¸åº”å·è½´
                    } else {
                        for (int p = 0; p < 5; ++p) {
                            int dx = j + dire[p][0], dy = k + dire[p][1];
                            if (dx >= 0 && dx < m && dy >= 0 && dy < n) {
                                // å‡å¦‚è¯¥ç‚¹å¯ä»¥ä½¿ç”¨æ°¸ä¹…å·è½´è½¬ç§»å¾—åˆ°çš„è¯ï¼Œæ„å‘³ç€ä»Šåæ‰€æœ‰çš„æ—¶é—´ï¼Œè¯¥ç‚¹å¯¹æ‹¥æœ‰æ°¸ä¹…å·è½´çš„çŠ¶æ€å‡æ˜¯å¼€æ”¾çš„
                                // å¦‚æœç›´æ¥ä¿®æ”¹dpæ•°ç»„è®°å½•çš„è¯ï¼Œæ„å‘³ç€å†ä¹˜ä¸ªTï¼Œä¼šè¶…æ—¶ï¼Œæ•…ç”¨é¢å¤–æ•°ç»„è®°å½•ä½œä¼˜åŒ–
                                // ä½¿ç”¨æ°¸ä¹…å·è½´
                                if (dp[i - 1][dx][dy][0]) {
                                    can[j][k][0] = true;
                                    can[j][k][1] = true;
                                } else if (dp[i - 1][dx][dy][1]) {
                                    can[j][k][1] = true;
                                }
                                // 0æ˜¯ä¸ç”¨æŒ‡æœ›èƒ½è½¬ç§»å¾—åˆ°äº†
                                dp[i][j][k][1] |= dp[i - 1][dx][dy][0];
                                dp[i][j][k][2] |= dp[i - 1][dx][dy][0];
                                dp[i][j][k][3] |= dp[i - 1][dx][dy][0] | dp[i - 1][dx][dy][1] | dp[i - 1][dx][dy][2];
                            }
                        }
                    }
                }
            }
        }
        return dp[t - 1][m - 1][n - 1][3];

    }
}
```



## [312. æˆ³æ°”çƒ](https://leetcode-cn.com/problems/burst-balloons/)

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

```java
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        int[] temp = new int[n+2];
        temp[0] = 1;
        temp[n+1] = 1;
        for(int i=0; i<n; ++i)  temp[i+1] = nums[i];
        // dp[i][j] è¡¨ç¤ºï¼ˆi - jï¼‰å¼€åŒºé—´å†…æœ€å¤§å€¼
        int[][] dp = new int[n+2][n+2];

        for(int len = 3; len <= n+2; ++len){
            // å·¦ç«¯ç‚¹
            for(int i=0; i <= n+2-len; ++i){
                int res = 0;
                // kä¸ºæœ€åä¸€ä¸ªç ´çš„æ°”çƒ
                for(int k=i+1; k<i+len-1; ++k){
                    res = Math.max(res, dp[i][k]+temp[i]*temp[k]*temp[i+len-1]+dp[k][i+len-1]);
                }
                dp[i][i+len-1] = res;
            }
        }
        return dp[0][n+1];

     }
}
```



## [410. åˆ†å‰²æ•°ç»„çš„æœ€å¤§å€¼](https://leetcode-cn.com/problems/split-array-largest-sum/)

ğŸ”´ğŸ˜’ğŸ˜œ

```java
class Solution {
    public int splitArray(int[] nums, int m) {
        int n = nums.length;
        // dp[i][j] è¡¨ç¤ºå‰iä¸ªåˆ†æˆjç»„çš„å°½é‡å°çš„å„è‡ªå’Œçš„æœ€å¤§å€¼
        int[][] dp = new int[n+1][m+1];
        int[] sub = new int[n+1];
        for(int i=0; i<n; ++i){
            dp[i+1][1] = dp[i][1] + nums[i];
            sub[i+1] = dp[i+1][1];
        }
        for(int i=2; i<=n; ++i){
            for(int j=2; j<=Math.min(i, m); ++j){
                dp[i][j] = Integer.MAX_VALUE;
                for(int k=j-1; k<i; ++k){
                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k][j-1], sub[i]-sub[k]));
                }
            }
        }
        return dp[n][m];
    }
}
```





## [6100. ç»Ÿè®¡æ”¾ç½®æˆ¿å­çš„æ–¹å¼æ•°](https://leetcode.cn/problems/count-number-of-ways-to-place-houses/)



ğŸ”´ğŸ”´ğŸ”´

```java
import java.util.*;

public class Solution {
    public int countHousePlacements(int n) {
       long[][] dp = new long[n+1][2];
       long mod = 1000000007;
       dp[1][0] = 1;
       dp[1][1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i][0] = (dp[i-1][0] + dp[i-1][1]) % mod;
            dp[i][1] = dp[i-1][0];
        }
        long ans = ((dp[n][1] + dp[n][0]) % mod);
        return (int) (ans * ans % mod);
    }
}
```



# å­—å…¸æ ‘

## [440. å­—å…¸åºçš„ç¬¬Kå°æ•°å­—](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)

ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´

```java
class Solution {
	public int findKthNumber(int n, int k) {
    	int cur=1;//ç¬¬ä¸€å­—å…¸åºå°çš„(å°±æ˜¯1)
    	int prefix=1;// å‰ç¼€ä»1å¼€å§‹
    	while(cur<k) {
    		int tmp=count(n,prefix); //å½“å‰prefixå³°çš„å€¼
    		if(tmp+cur>k) {// æ‰¾åˆ°äº†
    			prefix*=10; //å¾€ä¸‹å±‚éå†
    			cur++;//ä¸€ç›´éå†åˆ°ç¬¬Kä¸ªæ¨å‡ºå¾ªç¯
    		}else {
    			prefix++;//å»ä¸‹ä¸ªå³°å¤´(å‰ç¼€)éå†
    			cur+=tmp;//è·¨è¿‡äº†ä¸€ä¸ªå³°(å‰ç¼€) 
    		}
    	}//é€€å‡ºå¾ªç¯æ—¶ cur==k æ­£å¥½æ‰¾åˆ°
    	return prefix;
    }

	private int count(int n, int prefix) {
          	//ä¸æ–­å‘ä¸‹å±‚éå†å¯èƒ½ä¸€ä¸ªä¹˜10å°±æº¢å‡ºäº†, æ‰€ä»¥ç”¨long
		long cur=prefix;
		long next=cur+1;//ä¸‹ä¸€ä¸ªå‰ç¼€å³°å¤´
		int count=0;
		while(cur<=n) {
			count+=Math.min(n+1,next)-cur;//ä¸‹ä¸€å³°å¤´å‡å»æ­¤å³°å¤´
			 // å¦‚æœè¯´åˆšåˆšprefixæ˜¯1ï¼Œnextæ˜¯2ï¼Œé‚£ä¹ˆç°åœ¨åˆ†åˆ«å˜æˆ10å’Œ20
	        // 1ä¸ºå‰ç¼€çš„å­èŠ‚ç‚¹å¢åŠ 10ä¸ªï¼Œåå‰æ ‘å¢åŠ ä¸€å±‚, å˜æˆäº†ä¸¤å±‚
	        
	        // å¦‚æœè¯´ç°åœ¨prefixæ˜¯10ï¼Œnextæ˜¯20ï¼Œé‚£ä¹ˆç°åœ¨åˆ†åˆ«å˜æˆ100å’Œ200ï¼Œ
	        // 1ä¸ºå‰ç¼€çš„å­èŠ‚ç‚¹å¢åŠ 100ä¸ªï¼Œåå‰æ ‘åˆå¢åŠ äº†ä¸€å±‚ï¼Œå˜æˆäº†ä¸‰å±‚
			cur*=10;
			next*=10; //å¾€ä¸‹å±‚èµ°
		}
		return count;
	}
}
```



# äºŒå‰æ ‘+DP

## [LCP 34. äºŒå‰æ ‘æŸ“è‰²](https://leetcode-cn.com/problems/er-cha-shu-ran-se-UGC/)

ğŸ”´ğŸ”´ğŸ”´

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  
    public int maxValue(TreeNode root, int k) {
       int[] ans = dfs(root, k);
       int max = 0;
       for(int i=0; i<=k; ++i)  max = Math.max(max, ans[i]);
       return max;
    }

    public int[] dfs(TreeNode root, int k){
        // dp[i]ï¼ˆi>0ï¼‰ è¡¨ç¤ºå½“å‰ç‚¹åŠ ä¸Šè¿ç»­æŸ“è‰² i-1 ä¸ªç‚¹æ‰€è·å¾—çš„æœ€å¤§å€¼
        // dp[0]è¡¨ç¤ºä¸æŸ“å½“å‰ç‚¹æ‰€è·å¾—æœ€å¤§å€¼
        int[] dp = new int[k+1];
        if(root == null)    return dp;

        int l[] = dfs(root.left, k);
        int r[] = dfs(root.right, k);

        int ml = 0;
        int mr = 0;

        for(int i=0; i<=k; ++i){
            ml = Math.max(ml, l[i]);
            mr = Math.max(mr, r[i]);
        }
        
        dp[0] = ml + mr;


        for(int i=1; i<=k; ++i){
            for(int j=0; j<i; ++j){
                // å·¦è¾¹æŸ“ j ä¸ª å³è¾¹æŸ“ i - 1 -j ä¸ª
                dp[i] = Math.max(dp[i], root.val+l[j]+r[i-1-j]);
            }
        }

        return dp;
        
    }

}
```



# æ•°å­¦

## [172. é˜¶ä¹˜åçš„é›¶](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

ğŸ˜œğŸ˜œ

```java
class Solution {
    public int trailingZeroes(int n) {
        int ans = 0;
        for(int i=5; i<=n; i+=5){
            ans += digit(i);
        }
        return ans;
    }
    // æ±‚åŒ…å«5çš„æ•°é‡
    // 25->2  125->3   225->2
    public int digit(int k){
        if(k % 5 == 0)  return 1+digit(k/5);
        else return 0;
    }
}
```

ğŸ”´

```java
class Solution {
    public int trailingZeroes(int n) {
        int ans = 0;
        while(n != 0){
            n = n/5;
            ans += n;
        }
        return ans;
    }
    
}
/*
è¡¥å……ä¸€ä¸‹ä»¥130ä¸ºä¾‹å‡ºç°çš„æ•°ï¼š

ç¬¬ä¸€æ¬¡ï¼š5ï¼Œ10ï¼Œ15ï¼Œâ€¦ï¼Œ130ï¼Œè‡³å°‘åŒ…å«1ä¸ª5çš„æ•°ä¸º26ä¸ª

ç¬¬äºŒæ¬¡ï¼š25ï¼Œ50ï¼Œ75ï¼Œ100ï¼Œ125ï¼Œè‡³å°‘åŒ…å«2ä¸ª5çš„æ•°æœ‰è¿™5ä¸ª

ç¬¬ä¸‰æ¬¡ï¼š125ï¼Œå®ƒè‡³å°‘åŒ…å«3ä¸ª5ï¼ˆå…¶å®ä¹ŸåªåŒ…å«3ä¸ª5ï¼‰
*/
```



# ä½è¿ç®—

## [å‰‘æŒ‡ Offer II 001. æ•´æ•°é™¤æ³•](https://leetcode-cn.com/problems/xoh6Oh/)

ğŸ”´

```java
class Solution {
    public int divide(int a, int b) {
        if(a == 0 || b == 1)  return a;
        if(a == -2147483648 && b == -1)  return 2147483647;
        int flag = 1;
        if((a < 0 && b > 0) || (a > 0 && b < 0))    flag = -1;
        // è½¬å˜ä¸ºè´Ÿæ•° é˜²æ­¢æº¢å‡º
        a = a > 0 ? -a : a;
        b = b > 0 ? -b : b;
        int ans = 0;
        // å¿«é€Ÿå‡æ³•
        while(a <= b){
            int base = 1;
            int div = b;
            while(a - div <= div){
                div <<= 1;
                base <<= 1;
            }
            ans += base;
            a -= div;
            
        }
        return flag == 1 ? ans : -ans;
         
    }
    
}
```



## [Dasha and Nightmares](https://codeforces.com/contest/1800/problem/F)

ğŸ”´ğŸ”´ğŸ”´

```c++
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using ULL = unsigned long long;
using PII = pair<int,int>;
using PLL = pair<LL ,LL>;
using PULL = pair<ULL ,ULL>;
const int INF = 0X3F3F3F3F;
const int MOD = 1e9+7;
inline int mod(int x) { return x >= MOD ? x - MOD : x; }

// 2023-03-03 16:16:05


int main() {
    int n;
    cin>>n;
    string s;
    // v[0] å­˜å‚¨å­—ç¬¦ä¸²é•¿åº¦ä¸ºå¶æ•°çš„ä¿¡æ¯
    vector<vector<PII>> v(2);
    for (int i = 0; i < n; ++i) {
        cin>>s;
        // sum ä¸­æŸä½æŒ‡çš„çš„æŸä¸ªå­—æ¯æ˜¯å¦å­˜åœ¨
        // mask ä¸­æŸä½æŒ‡çš„æ˜¯æŸä¸ªå­—æ¯çš„ä¸ªæ•°æ˜¯å¥‡æ•°è¿˜æ˜¯å¶æ•°
        int sum = 0, mask = 0,k = 0;
        for (const auto &it: s){
            k = it - 'a';
            sum |= (1 << k);
            mask ^= (1 << k);
        }
        v[s.size() & 1].push_back({sum,mask});
    }
    // å­˜å‚¨æŸä¸ªçŠ¶æ€ä¸‹å¥‡æ•°é•¿åº¦çš„å­—ç¬¦ä¸²ä¸ªæ•°
    vector<int> cnt(1<<26, 0);
    LL  ans = 0;
    for (int i = 0; i < 26; ++i) {
        int all = ((1 << 26) - 1) ^ (1 << i);
        for (const auto &[sum,mask]: v[1]){
            if(!((sum>>i) & 1)) ++cnt[mask];
        }
        for (const auto &[sum,mask]: v[0]){
            // åˆ°è¾¾è¿™é‡Œæ—¶nightmareçš„é•¿åº¦è‚¯å®šæ˜¯å¶æ•°äº†ï¼Œå½“cnt[all ^ mask]ä¸ä¸º0æ—¶è¯´æ˜ä¸€å®šæ»¡è¶³ç¬¬ä¸‰å’Œç¬¬å››æ¡ä»¶äº†
            // be careful !!!
            if(!((sum>>i) & 1)) ans += cnt[all ^ mask];
        }
        for (const auto &[sum,mask]: v[1]){
            if(!((sum>>i) & 1)) --cnt[mask];
        }
    }
    cout<<ans<<'\n';
    return 0;
}
```



## [982. æŒ‰ä½ä¸ä¸ºé›¶çš„ä¸‰å…ƒç»„](https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/)

ğŸ”´

```c++
// ä¸€èˆ¬ç‰ˆæœ¬
//leetcode submit region begin(Prohibit modification and deletion)
// 2023-03-04 20:31:39
#include<bits/stdc++.h>

using namespace std;
class Solution {
public:
    int countTriplets(vector<int>& nums) {
        vector<int> cnt(1<<16,0);
        unordered_map<int,int> m;
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            ++m[nums[i]];
            for (int j = 0; j < n; ++j) {
                ++cnt[nums[i]&nums[j]];
            }
        }
        int ans = 0;
        for (int i = 0; i < (1 << 16); ++i) {
            for (int j = 0; j < n; ++j) {
                if(i & nums[j]){

                }else{
                    ans += cnt[i];
                }
            }
        }
        return ans;

    }
};
//leetcode submit region end(Prohibit modification and deletion)


// ä¼˜åŒ–ç‰ˆæœ¬ è§é¢˜è§£ï¼ï¼
class Solution {
public:
    int countTriplets(vector<int>& nums) {
        vector<int> cnt(1 << 16);
        for (int x: nums) {
            for (int y: nums) {
                ++cnt[x & y];
            }
        }
        int ans = 0;
        for (int x: nums) {
            x = x ^ 0xffff;
            for (int sub = x; sub; sub = (sub - 1) & x) {
                ans += cnt[sub];
            }
            ans += cnt[0];
        }
        return ans;
    }
};

```





# å¹¶æŸ¥é›†

## [ P1111ä¿®å¤å…¬è·¯ - æ´›è°·](https://www.luogu.com.cn/problem/P1111)
ğŸ˜ŠğŸ˜Š

```java
package my.stu;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Main {
    static int[] parent;
    static int[] rank;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int N = sc.nextInt();
        int M = sc.nextInt();
        parent = new int[N+1];
        rank = new int[N+1];
        for (int i = 1; i <= N; i++) {
            parent[i] = i;
            rank[i] = 1;
        }

        int[][] a = new int[M][3];
        for (int i = 0; i < M; i++) {
            a[i][0] = sc.nextInt();
            a[i][1] = sc.nextInt();
            a[i][2] = sc.nextInt();
        }

        // æŒ‰ç…§æ—¶é—´ä»å°åˆ°å¤§æ’åº
        Arrays.sort(a, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[2] - o2[2];
            }
        });
        
        int ans = 0;
        for (int[] ints : a) {
            // åŠ å…¥å¤±è´¥åˆ™è¯´æ˜ä¸¤ä¸ªæ˜¯è”é€šçš„ 
            // æˆåŠŸåˆ™è¯´æ˜åŸæœ¬ä¸è¿é€šï¼Œç°åœ¨è”é€šäº† éœ€è¦æ›´æ–° ans
            if(union(ints[0], ints[1])) ans = ints[2];
        }
        
        int k = find(1);
        for (int i = 2; i <= N; i++) {
            // è‹¥å­˜åœ¨ä¸¤ä¸ªç½‘ç»œåˆ™è¯´æ˜å­˜åœ¨ä¸¤ä¸ªæ‘åº„ä¸äº’é€š
            if(find(i) != k){
                System.out.println(-1);
                return;
            }
        }
        System.out.println(ans);

    }
    public static int find(int x){
        if(x == parent[x])  return x;
        return parent[x] = find(parent[x]);
    }
    public static boolean union(int x, int y){
        x = find(x);
        y = find(y);
        if(x == y) return false;
        if(rank[x] > rank[y])   parent[y] = x;
        else {
            if(rank[x] == rank[y])  rank[y]++;
            parent[x] = y;
        }
        return true;
    }

}

```





## [P3958 [NOIP2017 æé«˜ç»„] å¥¶é…ª - æ´›è°· ](https://www.luogu.com.cn/problem/P3958#submit)
ğŸ˜ŠğŸ˜Š

```java
package my.stu;

import sun.nio.ch.ThreadPool;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;
import java.util.concurrent.ThreadPoolExecutor;

public class Main {
    static int[] parent;
    static int[] rank;
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        // Tç»„æ•°æ®
        int T = sc.nextInt();
        while (T-- > 0){

            int n = sc.nextInt();
            int h = sc.nextInt();
            int r = sc.nextInt();
            long[][] arr = new long[n][3];
            long bet = (((long) r * (long) r)) << 2;
            for (int i = 0; i < n; i++) {
                arr[i][0] = sc.nextLong();
                arr[i][1] = sc.nextLong();
                arr[i][2] = sc.nextLong();
            }
            // ç¬¬n+1é¡¹ä¸ºä¸åº•éƒ¨ç›¸è¿  parent[n]
            // ç¬¬n+2é¡¹ä¸ºä¸é¡¶éƒ¨ç›¸è¿  parent[n+1]
            parent = new int[n+2];
            rank = new int[n+2];
            for (int i = 0; i < n + 2; i++) {
                parent[i] = i;
                rank[i] = 1;
            }
            for (int i = 0; i < n; i++) {
                // ä¸åº•éƒ¨ç›¸è¿åŠ å…¥åº•éƒ¨
                if(arr[i][2] <= r)  union(i, n);
                // ä¸é¡¶éƒ¨ç›¸è¿åŠ å…¥é¡¶éƒ¨
                if(arr[i][2] + r >= h)  union(i, n+1);
                for (int j = 0; j < i; j++) {
                    long dis = (arr[i][0] - arr[j][0]) * (arr[i][0] - arr[j][0])
                            +  (arr[i][1] - arr[j][1]) * (arr[i][1] - arr[j][1])
                            +  (arr[i][2] - arr[j][2]) * (arr[i][2] - arr[j][2]);
                    if(dis <= bet){
                        union(i, j);
                    }
                }
            }
            // åº•éƒ¨å’Œé¡¶éƒ¨å±äºåŒä¸€ä¸ªç½‘ç»œåˆ™è¯´æ˜å¯ä»¥ä»åº•éƒ¨åˆ°è¾¾é¡¶éƒ¨
            if(find(n) == find(n+1)) System.out.println("Yes");
            else System.out.println("No");


        }


    }
    public static int find(int x){
        if(x == parent[x])  return x;
        return parent[x] = find(parent[x]);
    }
    public static boolean union(int x, int y){
        x = find(x);
        y = find(y);

        if(x == y) return false;
        if(rank[x] > rank[y])   parent[y] = x;
        else {
            if(rank[x] == rank[y])  rank[y]++;
            parent[x] = y;
        }
        return true;
    }



}

```



## [685. å†—ä½™è¿æ¥ II](https://leetcode-cn.com/problems/redundant-connection-ii/)

ğŸ”´ğŸ”´ğŸ”´

```java
class Solution {

    int[] parent;

    public int[] findRedundantDirectedConnection(int[][] edges) {
        int[] ans = new int[2];
        int n = edges.length;
        parent = new int[n+1];
        
        for(int i=0; i<=n; ++i){
            parent[i] = i;
        }
        UnionFind uf = new UnionFind(n+1);
        // æ˜¯å¦å‘ç”Ÿå†²çª(å…¥åº¦ä¸º2)
        int conf = -1;
        // æ˜¯å¦æœ‰ç¯
        int cycle = -1;
        for(int i=0; i<n; ++i){
            int[] edge = edges[i];
            int from = edge[0];
            int to = edge[1];
            // å­˜åœ¨å…¥åº¦ä¸º2çš„ç‚¹
            if(to != parent[to]){
                conf = i;
            }else{
                // å­˜åœ¨ç¯
                parent[to] = from;
                if(uf.find(from) == uf.find(to)){
                    cycle = to;
                }else{
                    uf.union(from, to);
                }
            }
            
        }
        // æ²¡æœ‰å†²çª ä¸€å®šå­˜åœ¨ç¯çš„æƒ…å†µ
        if(conf < 0){
            return new int[]{parent[cycle], cycle};
        }
        
        int[] confEdge = edges[conf];
        
        if(cycle < 0){
            // ä¸è¿æ¥ä¸Šå†²çªç‚¹æ— ç¯ï¼Œè¯´æ˜å¯è¡Œï¼Œåˆ é™¤ç¬¬äºŒä¸ªå…¥åº¦
            //System.out.println(conf+" "+confEdge[0]+" "+confEdge[1]+"+++");
            return new int[]{confEdge[0], confEdge[1]};
        }else{
            // ä¸è¿æ¥ä¸Šå†²çªç‚¹æœ‰ç¯, è¯´æ˜ç¬¬ä¸€ä¸ªå…¥åº¦éœ€è¦åˆ é™¤
            //System.out.println(conf+" "+confEdge[0]+" "+confEdge[1]+" ");
            return new int[]{parent[confEdge[1]], confEdge[1]};
        }

    }


   
}
class UnionFind {
    int[] ancestor;

    public UnionFind(int n) {
        ancestor = new int[n];
        for (int i = 0; i < n; ++i) {
            ancestor[i] = i;
        }
    }

    public void union(int index1, int index2) {
        ancestor[find(index1)] = find(index2);
    }

    public int find(int index) {
        if (ancestor[index] != index) {
            ancestor[index] = find(ancestor[index]);
        }
        return ancestor[index];
    }
}


```



## [924. å°½é‡å‡å°‘æ¶æ„è½¯ä»¶çš„ä¼ æ’­](https://leetcode-cn.com/problems/minimize-malware-spread/)

ğŸ˜’ğŸ˜’




```java
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int ans = 1000;
        int n = graph.length;
        UnionFind uf = new UnionFind(n);
        for(int i=0; i<n; ++i){
            for(int j=i+1; j<n; ++j){
                if(graph[i][j] == 1){
                    uf.union(i, j);
                }
            }
        }
        // å…ˆä»å°åˆ°å¤§æ’ä¸ªåº
        Arrays.sort(initial);
        // è®°å½•æŸä¸ªç½‘ç»œè¢«æ±¡æŸ“çš„ä¸ªæ•°
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0; i<initial.length; ++i){
            int par = uf.find(initial[i]);
            int count = map.getOrDefault(par, 0)+1;
            map.put(par, count);
        }

        // æŒ‡å‘åˆé€‚çš„ç½‘ç»œå›¾çš„æ ¹
        int pos = -1;
        // åˆé€‚çš„ç½‘ç»œå›¾ä¸­èŠ‚ç‚¹çš„æ•°é‡
        int num = -1;

        Set<Integer> set = map.keySet();

        // ç­”æ¡ˆä¸å”¯ä¸€
        Set<Integer> posSet = new HashSet<>();

        for(int key : set){
            // ç½‘ç»œå›¾ä¸­æ±¡æŸ“æºå¤§äº 1 ä¸è€ƒè™‘
            if(map.get(key) > 1)    continue;
            // ç½‘ç»œå›¾ä¸­æ±¡æŸ“æº == 1 è€ƒè™‘è¯¥ç½‘ç»œå›¾ä¸­çš„æ•°é‡æ˜¯å¦æ˜¯æœ€å¤§çš„
            int count = uf.map.get(key);
            if(count > num) {
                //System.out.println("---"+key+" "+count);
                pos = key;
                num = count;
                posSet.clear();
                posSet.add(key);
            }
            else if(count == num){
                posSet.add(key);
            }
        }
        
        // set = uf.map.keySet();
        // for(int key : set){
        //     System.out.println(key+" "+uf.map.get(key));
        // }

        // å…¨éƒ½æ˜¯æ±¡æŸ“æºå¤§äº 1 çš„ ç›´æ¥è¿”å›initial[0]
        if(pos == -1)   return initial[0];
        for(int i=0; i<initial.length; ++i){
            int par = uf.find(initial[i]);
            // ç¬¬ä¸€ä¸ªæœ€ä¼˜è§£ ç´¢å¼•ä¸€å®šæ˜¯æœ€å°çš„ï¼ˆä¹‹å‰æ’åºäº†ï¼‰
            if(posSet.contains(par) ){
                ans = initial[i];
                break;
            }
        }
        return ans;

    }
}
class UnionFind{
    int[] parent;
    // è®°å½•ç½‘ç»œå›¾ä¸­èŠ‚ç‚¹æ•°ç›®
    Map<Integer, Integer> map;
    public UnionFind(int capity){
        parent = new int[capity];
        map = new HashMap<>();
        for(int i=0; i<capity; ++i){
            parent[i] = i;
            map.put(i, 1);
        }
    }

    public int find(int x){
        return x == parent[x] ? x : (parent[x] = find(parent[x]));
    }

    public void union(int x, int y){
        x = find(x);
        y = find(y);
        if(x == y)  return;
        parent[y] = x;
        map.put(x, map.get(x)+map.get(y));
        map.remove(y);
    }
}

```



# çº¿æ®µæ ‘

## [307. åŒºåŸŸå’Œæ£€ç´¢ - æ•°ç»„å¯ä¿®æ”¹](https://leetcode-cn.com/problems/range-sum-query-mutable/)

ğŸ˜ŠğŸ˜Š

```java
class NumArray {
    int[] nums;
    int[] ans;
    public NumArray(int[] nums) {
        this.nums = nums;
        if(nums.length != 0){
            this.ans = new int[nums.length << 2];
            buildTree(0, 0, nums.length - 1);
        }
    }
    
    // å•ç‚¹æ›´æ–°
    public void update(int index, int val) {
        update(index, val, 0, 0, nums.length - 1);
    }
    
    public int sumRange(int left, int right) {
        return query(0, 0, nums.length - 1, left, right);
    }

    // å»ºæ ‘
    private void buildTree(int node, int left, int right){
        if(left == right){
            ans[node] = nums[left];
            return;
        }
        int mid = (left + right) >> 1;
        buildTree((node << 1) + 1, left, mid);
        buildTree((node << 1) + 2, mid + 1, right);
        ans[node] = ans[(node << 1) + 1] + ans[(node << 1) + 2];
        return;
    }
    // å•ç‚¹æ›´æ–°
    private void update(int index, int val, int node, int left, int right){
        // ä¸åœ¨èŒƒå›´å†…ç›´æ¥é€€å‡º
        if(index < left || index > right)   return;
        if(left == right){
            nums[left] = val;
            ans[node] = val;
            return;
        }
        int mid = (left + right) >> 1;
        update(index, val, (node << 1) + 1, left, mid);
        update(index, val, (node << 1) + 2, mid + 1, right);
        ans[node] = ans[(node << 1) + 1] + ans[(node << 1) + 2];
        return;

    }

    private int query(int node, int left, int right, int L, int R){
        if(L <= left && right <= R) return ans[node];
        int res = 0;
        int mid = (left + right) >> 1;
        if(L <= mid)    res += query((node << 1) + 1, left, mid, L, R);
        if(R >  mid)    res += query((node << 1) + 2, mid + 1, right, L, R);
        return res;
    }

}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(index,val);
 * int param_2 = obj.sumRange(left,right);
 */
```





## [LCP 05. å‘ LeetCoin](https://leetcode-cn.com/problems/coin-bonus/)

ğŸ”´ğŸ”´ğŸ˜Š

```java
class Solution {
    // åˆ†é…å”¯ä¸€æ ‡è®°
    int vis = 1;
    public int[] bonus(int n, int[][] leadership, int[][] operations) {
        Tree[] tree = new Tree[n+1];
        // å…ˆå»ºç«‹å±‚çº§å…³ç³»
        for(int[] ship : leadership){
            if(tree[ship[0]] == null)   tree[ship[0]] = new Tree(ship[0]);
            if(tree[ship[1]] == null)   tree[ship[1]] = new Tree(ship[1]);
            tree[ship[0]].children.add(tree[ship[1]]);
        }
        // è¡¨ç¤ºæ˜ å°„
        int[] trans = new int[n+1];
        // è¡¨ç¤ºæ¯ä¸ªç‚¹çš„ä¸‹å±æ€»æ•°
        int[] sum = new int[n+1];
        // å»ºç«‹æ˜ å°„ä»¥åŠè®¡ç®—æ¯ä¸ªç‚¹çš„æ‰€æœ‰ä¸‹å±æ€»æ•°
        dfs(tree[1], trans,sum);
        // çº¿æ®µæ ‘
        TreeNode root = new TreeNode(n);
        List<Integer> res = new ArrayList<>();
        for(int[] operation : operations){
            if(operation[0] == 1)   root.update(1, 1, n, trans[operation[1]], trans[operation[1]], operation[2]);
            else if(operation[0] == 2)  root.update(1, 1, n, trans[operation[1]], trans[operation[1]]+sum[operation[1]], operation[2]);
            else{
                res.add(root.query(1, 1, n, trans[operation[1]],trans[operation[1]]+sum[operation[1]]));
            }
        }
        int[] ans = new int[res.size()];
        for(int i=0; i<ans.length; ++i){
            ans[i] = res.get(i);
        }
        return ans;



    }
    public int dfs(Tree tree, int[] trans, int[] sum){
        // åˆ†é…å”¯ä¸€ id
        trans[tree.id] = vis++;
        for(int i=0; i<tree.children.size(); ++i){
            sum[tree.id] += dfs(tree.children.get(i), trans, sum);
        }
        return sum[tree.id] + 1;
    }
    

    
}
class Tree{
    int id;
    List<Tree> children;
    public Tree(int id){
        this.id = id;
        children = new ArrayList<>();
    }
}
class TreeNode{
    int[] mask;
    int[] res;
    int mod;
    public TreeNode(int n){
        mask = new int[n << 2];
        res = new int[n << 2];
        mod = 1000000007;
    }

    public void update(int index, int left, int right, int L, int R, int value){

        if(L <= left && right <= R){
            mark(index, left, right, value);
            return;
        }
        pushDown(index, left, right);
        int mid = (left + right) >> 1;
        if(L <= mid) update(getLeft(index), left, mid, L, R, value);
        if(R > mid) update(getRight(index), mid+1, right, L, R, value);
        pushUp(index);
    }
    public int query(int index, int left, int right, int L, int R){
        if(L <= left && right <= R)  return res[index];
        pushDown(index, left, right);
        int mid = (left + right) >> 1;
        int ans = 0;
        if(L <= mid)    ans = query(getLeft(index), left, mid, L, R)%mod;
        if(R > mid)     ans = (ans + query(getRight(index), mid+1, right, L, R))%mod;
        return ans;
    }

    // å·¦å­©å­
    public int getLeft(int x){
        return x << 1;
    }
    // å³å­©å­
    public int getRight(int x){
        return (x << 1) | 1;
    }
    // æ‡’æƒ°æ ‡è®°
    public void mark(int index, int left, int right,int value){
        mask[index] += value;
        res[index] = (res[index]+(right - left + 1) * value)%mod;
    }
    // è®¡ç®—å½“å‰ç‚¹æ€»å’Œ
    public void pushUp(int x){
        res[x] = (res[getLeft(x)] + res[getRight(x)])%mod;
    }
    // å‘ä¸‹ä¼ æ’­æ ‡è®°
    public void pushDown(int index, int left, int right){
        int mid = (left + right) >> 1;
        mark(getLeft(index), left, mid, mask[index]);
        mark(getRight(index), mid+1, right, mask[index]);
        mask[index] = 0;
    }

}
```



# å¹¿åº¦ä¼˜å…ˆæœç´¢

## [LCP 09. æœ€å°è·³è·ƒæ¬¡æ•°](https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu/)

ğŸ˜œğŸ˜œ

```java
class Solution {
    public int minJump(int[] jump) {
        int n = jump.length;
        Queue<Integer> queue = new LinkedList<>();
        // [0 ~ low-1]å‡è¢«æœç´¢åˆ°ï¼Œæ²¡å¿…è¦å†æœç´¢
        int low = 0;
        // è·³è½¬æ¬¡æ•°
        int deep = 0;

        queue.offer(0);
        // ä¿å­˜è¯¥ç‚¹æ˜¯å¦å·²ç»æœç´¢åˆ°
        boolean[] vis = new boolean[n];
        while(!queue.isEmpty()){
            // æ¬¡æ•°+1
            deep++;
            int size = queue.size();
            for(int i=0; i<size; ++i){
                int node = queue.poll();
                // å·²ç»æœç´¢åˆ°è¯¥ç‚¹ å°†vis[node]è®¾ç½®ä¸ºtrue
                vis[node] = true;
                // å¯ä»¥è¶Šå‡ºè¾¹ç•Œ è¿”å›æ­¥æ•°
                if(node + jump[node] >= n)  return deep;
                // å‘å³è·³è½¬çš„ç›®çš„åœ°æœªè¢«æœç´¢ é‚£ä¹ˆå°±å»æœç´¢
                if(!vis[node + jump[node]]) queue.offer(node + jump[node]);
                // å‘å·¦æœç´¢
                while(low < node){
                    // è¯¥ç‚¹æœªè¢«æœç´¢åˆ° åŠ å…¥é˜Ÿåˆ—
                    if(!vis[low]) queue.offer(low++);
                    // å¦åˆ™è·³è¿‡
                    else low++;
                }
            }
        }
        // æ²¡å•¥ç”¨ ä¸ºäº†ä¸æŠ¥é”™
        return 0;
    }
}
```

## [675. ä¸ºé«˜å°”å¤«æ¯”èµ›ç æ ‘](https://leetcode.cn/problems/cut-off-trees-for-golf-event/)

ğŸ”´ğŸ”´ğŸ˜œ

```java
import java.util.*;

public class Solution {
    public static void main(String[] args) {
        new Solution().cutOffTree(new ArrayList<List<Integer>>(){{
            add(new ArrayList<Integer>(){{add(1);add(2);add(3);}});
            add(new ArrayList<Integer>(){{add(0);add(0);add(4);}});
            add(new ArrayList<Integer>(){{add(7);add(6);add(5);}});
        }});
    }

    int[] dy = new int[]{1,-1,0,0};
    int[] dx = new int[]{0,0,1,-1};
    // è¿”å›å€¼ [0] -> åæ ‡  (tx<<16)+ty
    //       [1] -> æ­¥æ•°
    private int[] bfs(int x,int y,int[][] arr, int tar){
        if(arr[x][y] == tar){
            return new int[]{(x<<16)+y,0};
        }
        Deque<Integer> queue = new ArrayDeque<>();
        queue.offer((x <<16) + y);
        Set<Integer> set = new HashSet<>();
        set.add((x <<16) + y);
        int deep = 0;
        while (!queue.isEmpty()){
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int cx = queue.poll();
                int cy = cx & 0xffff;
                cx >>= 16;
                if(arr[cx][cy] == tar) return new int[]{(cx << 16)+cy,deep};
                for (int j = 0; j < 4; j++) {
                    int tx = cx + dx[j];
                    int ty = cy + dy[j];
                    if(tx < 0 || tx >= arr.length || ty < 0 || ty >= arr[0].length || arr[tx][ty] == 0 ){
                        continue;
                    }
                    if(set.contains((tx << 16) + ty)){
                        continue;
                    }
                    set.add((tx << 16) + ty);
                    queue.offer((tx << 16) + ty);
                }
            }
            deep++;
        }
        return new int[]{-1,-1};


    }
    public int cutOffTree(List<List<Integer>> forest) {
        int m = forest.size();
        int n = forest.get(0).size();
        int[][] arr = new int[m][n];
        PriorityQueue<Integer> pq  = new PriorityQueue<>(((o1, o2) -> o1-o2));

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                arr[i][j] = forest.get(i).get(j);
                if(arr[i][j] > 1)   {
                    pq.offer(arr[i][j]);
                }
            }
        }
        if(arr[0][0] == 0)   return -1;
        int cx = 0;
        int cy = 0;
        int res = 0;
        while (!pq.isEmpty()){
            // ä»å½“å‰ä½ç½®æœç´¢ä¸‹ä¸€ä¸ªæœ€å°æ•°
            int[] t = bfs(cx,cy,arr,pq.poll());
            if(t[0] == -1)  return -1;
            cx = t[0] >> 16;
            cy = t[0] & 0xffff;
            arr[cx][cy] = 1;
            res += t[1];
        }
        return res;

    }
}
```





# æ‹“æ‰‘æ’åº

## [310. æœ€å°é«˜åº¦æ ‘](https://leetcode-cn.com/problems/minimum-height-trees/)

ğŸ”´ğŸ˜’

```java
class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<Integer> ans = new ArrayList<Integer>();
        if (n == 1) {
            ans.add(0);
            return ans;
        }
        int[] degree = new int[n];
        List<Integer>[] adj = new List[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new ArrayList<Integer>();
        }
        for (int[] edge : edges) {
            adj[edge[0]].add(edge[1]);
            adj[edge[1]].add(edge[0]);
            degree[edge[0]]++;
            degree[edge[1]]++;
        }
        Queue<Integer> queue = new ArrayDeque<Integer>();
        for (int i = 0; i < n; i++) {
            if (degree[i] == 1) {
                queue.offer(i);
            }
        }
        int remainNodes = n;
        while (remainNodes > 2) {
            int sz = queue.size();
            remainNodes -= sz;
            for (int i = 0; i < sz; i++) {
                int curr = queue.poll();
                for (int v : adj[curr]) {
                    degree[v]--;
                    if (degree[v] == 1) {
                        queue.offer(v);
                    }
                }
            }
        }
        while (!queue.isEmpty()) {
            ans.add(queue.poll());
        }
        return ans;
    }
}


```



# æ»‘åŠ¨çª—å£

## [30. ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)

ğŸ˜œğŸ˜‹

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        Map<String, Integer> map = new HashMap<>();
        List<Integer> ans = new ArrayList<>();
        for(String word : words){
            map.put(word, map.getOrDefault(word, 0)+1);
        }
        int n = s.length();
        int p = words[0].length();
        for(int i=0; i<p; ++i){
            Map<String, Integer> tmp = new HashMap<>();
            int cnt = 0;
            // æ¯pä¸ªä¸ºä¸€ç»„è¿›è¡Œæ‰«æ
            // jè¡¨ç¤ºä»¥jä¸ºç»“å°¾çš„å­å­—ç¬¦ä¸²èƒ½åŒ¹é…å¤šå°‘words cntä¸ºè®¡æ•°å€¼
            for(int j=i+p-1; j<n; j+=p){
                String cur = s.substring(j-p+1, j+1);
                if(map.getOrDefault(cur, -1) == -1){
                    tmp.clear();
                    cnt = 0;
                    continue;
                }
                // æœªæŠŠcurä½¿ç”¨å®Œæˆ–è€…æœªä½¿ç”¨ç›´æ¥åŠ å…¥tmpå¹¶æ›´æ–°è®¡æ•°å€¼å³å¯
                if(map.getOrDefault(cur, -1) > tmp.getOrDefault(cur, 0)){
                    tmp.put(cur, tmp.getOrDefault(cur, 0)+1);
                    cnt++;
                }else{
                    // è®¡ç®—å‡ºèµ·å§‹ä½ç½®
                    int left = j-p+1-cnt*p;
                    // å½“æŠŠcurä½¿ç”¨å®Œäº†é‚£ä¹ˆå°±éœ€è¦å·¦æŒ‡é’ˆå‘å³ç§»åŠ¨
                    while(map.get(cur) == tmp.get(cur)){
                        String del = s.substring(left, left+p);
                        tmp.put(del, tmp.get(del)-1);
                        left += p;
                        cnt--;
                    }
                    tmp.put(cur, tmp.getOrDefault(cur, 0)+1);
                    cnt++;
                }
                // ä»¥å½“å‰jä¸ºç»“å°¾çš„å­å­—ç¬¦ä¸²å®Œå…¨åŒ¹é…words è®¡ç®—å‡ºå·¦æŒ‡é’ˆåŠ å…¥ç­”æ¡ˆå³å¯
                if(cnt == words.length){
                    ans.add(j-cnt*p+1);
                }
            }
        }
        //ans.sort();
        return ans;
    }
}
```



# äºŒåˆ†

## [ å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

ğŸ”´ğŸ”´ğŸ˜’

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int left = (m+n+1) / 2;
        int right = (m+n+2) / 2;
        return (findKth(nums1,0,nums2,0,left) + findKth(nums1,0,nums2,0,right))/2.0;
    }
    // i -> nums1 èµ·å§‹ä½ç½® 
    // j -> nums2 èµ·å§‹ä½ç½®
    private int findKth(int[] nums1, int i, int[] nums2, int j, int k){
        if(i >= nums1.length)   return nums2[j+k-1];
        if(j >= nums2.length)   return nums1[i+k-1];
        if(k == 1)  return Math.min(nums1[i], nums2[j]);
        int m1 = (i + k / 2 - 1 < nums1.length) ? nums1[i+k/2-1] : Integer.MAX_VALUE;
        int m2 = (j + k / 2 - 1 < nums2.length) ? nums2[j+k/2-1] : Integer.MAX_VALUE;
        if(m1 < m2){
            return findKth(nums1, i+k/2, nums2, j, k-k/2);
        }else{
            return findKth(nums1, i, nums2, j+k/2, k-k/2);
        }
    }
}
```





# Rolling Hash



## [Remove Two Letters](https://codeforces.com/contest/1800/problem/D)

ğŸ”´ğŸ”´

```c++
#include <bits/stdc++.h>
using namespace std;
using UC= unsigned char;
using US = unsigned short;
using UI = unsigned int;
using LL = long long;
using ULL = unsigned long long;
using PII = pair<int,int>;
using PLL = pair<long long ,long long>;
const int INF = 0X3F3F3F3F;
const int MOD = 1e9+7;
inline int mod(int x) { return x >= MOD ? x - MOD : x; }
// 2023-03-03 11:08:58
// START CUT
const int K = 2;
typedef array<int, K> vec;
vec P = {342325337, 342325331};
// vec P = {(int)1e9 + 7, (int)1e9 + 9};
vec operator *(const vec& a, const vec& b) {
    return {(int)(1LL * a[0] * b[0] % MOD), (int)(1LL * a[1] * b[1] % MOD)};
}
vec operator +(const vec& a, const vec& b) {
    return {mod(a[0] + b[0]), mod(a[1] + b[1])};
}
vec operator -(const vec& a, const vec& b) {
    return {mod(a[0] + MOD - b[0]), mod(a[1] + MOD - b[1])};
}
vec operator *(const vec& a, int b) { return a * vec{b, b}; };
vec operator +(const vec& a, int b) { return a + vec{b, b}; };
vec operator -(const vec& a, int b) { return a - vec{b, b}; };
 
struct RollingHash {
    vector<vec> p, pre;
    RollingHash(const string& s) {
        int n = s.size();
        p.resize(n + 1);
        pre.resize(n + 1);
        p[0] = {1, 1};
        for (int i = 0; i < n; ++i) {
            pre[i + 1] = pre[i] * P + (s[i] - 'a');
            p[i + 1] = p[i] * P;
        }
    }
    // æ±‚s[L] ~ s[R-1]çš„hash
    vec query(int L, int R) {
        return pre[R] - pre[L] * p[R - L];
    }
};
// END CUT
 
int main() {
    int cas;
    cin >> cas;
    while (cas--) {
        int n;
        string s;
        cin >> n >> s;
        RollingHash H(s);
        set<vec> A;
        for (int i = 0; i + 2 <= n; ++i) {
            auto L = H.query(0, i);
            auto R = H.query(i + 2, n);
            auto cur = H.p[n - i - 2] * L + R;
            A.insert(cur);
        }
        cout << A.size() << '\n';
    }
    return 0;
}
```



# æ¢æ ¹DP

## [ç»Ÿè®¡å¯èƒ½çš„æ ‘æ ¹æ•°ç›®](https://leetcode.cn/problems/count-number-of-possible-root-nodes/)

ğŸ”´

```c++
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using ULL = unsigned long long;
using PII = pair<int,int>;
using PLL = pair<LL ,LL>;
using PULL = pair<ULL ,ULL>;
const int INF = 0X3F3F3F3F;
const int MOD = 1e9+7;
inline int mod(int x) { return x >= MOD ? x - MOD : x; }

// 2023-03-06 11:12:56
class Solution {
public:
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        int n = edges.size() + 1, cnt = 0,ans = 0;;
        vector<vector<int>> g(n);
        set<PII> f;
        for (const auto &edge: edges){
            g[edge[0]].push_back(edge[1]);
            g[edge[1]].push_back(edge[0]);
        }

        for (const auto &guess: guesses) f.insert({guess[0], guess[1]});
        vector<bool> used(n,false);
        used[0] = true;
        // ä»¥0ä¸ºæ ¹æ—¶è®°å½•æœ‰å¤šå°‘è¢«çŒœå‡ºæ¥äº†
        function<void(int)> dfs_tree = [&](int node){
            for (const auto &nxt: g[node]){
                if(used[nxt]) continue;
                if(f.find({node, nxt}) != f.end())  ++cnt;
                used[nxt] = true;
                dfs_tree(nxt);
                used[nxt] = false;
            }
        };
        dfs_tree(0);
        if(cnt >= k)    ++ans;
        // æ¢æ ¹
        function<void(int,int)> dfs = [&](int node,int cnt){
            for (const auto &nxt: g[node]){
                if(used[nxt]) continue;
                // è¿™é‡Œå¿…é¡»ç”³è¯·ä¸€ä¸ªæ–°å˜é‡å­˜å‚¨cntï¼Œ
                // å¦‚æœç›´æ¥å¯¹cntæ“ä½œæ˜¯é”™è¯¯çš„ï¼Œç›´æ¥å¯¹cntæ“ä½œå¯ä»¥ç†è§£ä¸ºnxtçš„å…„å¼ŸèŠ‚ç‚¹ä¼šå½±å“nxtèŠ‚ç‚¹
                int p = cnt;
                if(f.find({node, nxt}) != f.end())  --p;
                if(f.find({nxt,node}) != f.end())   ++p;
                if(p >= k) ++ans;
                used[nxt] = true;
                dfs(nxt, p);
            }
        };
        dfs(0,cnt);
        return ans;

    }
};


```



## [Problem - 219D - Codeforces](https://codeforces.com/problemset/problem/219/D)

ğŸ”´

```c++
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using ULL = unsigned long long;
using PII = pair<int,int>;
using PLL = pair<LL ,LL>;
using PULL = pair<ULL ,ULL>;
const int INF = 0X3F3F3F3F;
const int MOD = 1e9+7;
inline int mod(int x) { return x >= MOD ? x - MOD : x; }

// 2023-03-06 11:12:56
// https://leetcode.cn/problems/count-number-of-possible-root-nodes/
//class Solution {
//public:
//    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
//        int n = edges.size() + 1, cnt = 0,ans = 0;;
//        vector<vector<int>> g(n);
//        set<PII> f;
//        for (const auto &edge: edges){
//            g[edge[0]].push_back(edge[1]);
//            g[edge[1]].push_back(edge[0]);
//        }
//
//        for (const auto &guess: guesses) f.insert({guess[0], guess[1]});
//        vector<bool> used(n,false);
//        used[0] = true;
//        function<void(int)> dfs_tree = [&](int node){
//            for (const auto &nxt: g[node]){
//                if(used[nxt]) continue;
//                if(f.find({node, nxt}) != f.end())  ++cnt;
//                used[nxt] = true;
//                dfs_tree(nxt);
//                used[nxt] = false;
//            }
//        };
//        dfs_tree(0);
//        if(cnt >= k)    ++ans;
//        function<void(int,int)> dfs = [&](int node,int cnt){
//            for (const auto &nxt: g[node]){
//                if(used[nxt]) continue;
//                int p = cnt;
//                if(f.find({node, nxt}) != f.end())  --p;
//                if(f.find({nxt,node}) != f.end())   ++p;
//                if(p >= k) ++ans;
//                used[nxt] = true;
//                dfs(nxt, p);
//            }
//        };
//        dfs(0,cnt);
//        return ans;
//
//    }
//};

int main() {
    int n = 0,cnt = 0;
    set<PII> s;
    cin>>n;
    vector<vector<int>> g(n+1);
    for (int i = 0; i < n - 1; ++i) {
        int a,b;
        cin>>a>>b;
        g[a].push_back(b);
        g[b].push_back(a);
        s.insert({a,b});
    }
    vector<bool> used(n+1,false);
    used[1] = true;
    function<void(int)> dfs_1 = [&](int node){
        for (const auto &nxt: g[node]){
            if(used[nxt]) continue;
            if(s.find({node, nxt}) == s.end())    ++cnt;
            used[nxt] = true;
            dfs_1(nxt);
            used[nxt] = false;
        }
    };
    dfs_1(1);
    int ans = cnt;
    vector<int> v = {1};
    function<void(int, int)> dfs_2 = [&](int node, int cnt){
        for (const auto &nxt: g[node]){
            if(used[nxt]) continue;
            int p = cnt;
            if(s.find({node, nxt}) == s.end())    --p;
            else    ++p;
            if(p == ans){
                v.push_back(nxt);
            }else if(p < ans){
                ans = p;
                v.clear();
                v.push_back(nxt);
            }
            used[nxt] = true;
            dfs_2(nxt, p);
        }
    };
    dfs_2(1,cnt);
    sort(v.begin(),v.end());
    cout<<ans<<endl;
    for (const auto &item: v){
        cout<<item<<' ';
    }


    return 0;
}

```



# æ±‚é€†åºå¯¹

## æš´åŠ›æ±‚è§£

ç•¥

## å½’å¹¶æ’åº

```c++
#include<bits/stdc++.h>
using namespace std;
// 107. è¶…å¿«é€Ÿæ’åº
// https://www.acwing.com/problem/content/109/
// å½’å¹¶æ’åºæ±‚é€†åºå¯¹
const int N = 500050;
int a[N],b[N];
long long  merge_sort(int l, int r)
{
    if(l >= r)  return 0;
    int mid = (l + r) >> 1;
    long long ans = merge_sort(l, mid) + merge_sort(mid+1, r); 
    int i = l, j = mid+1, k = 0;
    while (i <= mid && j <= r)
    {
        if(a[i] <= a[j])    b[k++] = a[i++];
        else{
            b[k++] = a[j++];
            ans += mid - i + 1;	// [i,mid]ä¸­çš„æ¯ä¸ªå€¼éƒ½æ¯”a[j]å¤§ æ•…åº”å¢åŠ é€†åºå¯¹mid - i + 1ä¸ª
        }
    }
    while (i <= mid)    b[k++] = a[i++];
    while (j <= r)  b[k++] = a[j++];
    
    for(i=l,j=0; i<=r; ++i,++j){
        a[i] = b[j];
    }
    return ans;
}
int main()
{
    int n;
    cin>>n;
    while (n)
    {
        for(int i=0; i<n; ++i)  cin>>a[i];  
        cout<<merge_sort(0, n-1)<<endl;
        cin>>n;
    }
}
```



## æ ‘çŠ¶æ•°ç»„

// TODO